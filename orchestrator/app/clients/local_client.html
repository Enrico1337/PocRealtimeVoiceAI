<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proof of Concept Voice AI - Local</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            color: #fff;
        }
        .container {
            text-align: center;
            width: 100%;
            max-width: 800px;
        }
        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #e94560;
        }
        .subtitle {
            color: #8892b0;
            margin-bottom: 1.5rem;
        }
        .mode-badge {
            display: inline-block;
            background: #4a4a6a;
            color: #6bcb77;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-bottom: 1rem;
        }
        .status {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .status-indicator.disconnected { background: #ff6b6b; }
        .status-indicator.connecting { background: #ffd93d; }
        .status-indicator.connected { background: #6bcb77; }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }
        button:hover:not(:disabled) {
            background: #ff6b6b;
            transform: translateY(-2px);
        }
        button:disabled {
            background: #4a4a6a;
            cursor: not-allowed;
        }
        .button-secondary {
            background: #4a4a6a;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        .button-secondary:hover:not(:disabled) {
            background: #5a5a7a;
        }
        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        @media (max-width: 600px) {
            .panels {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 1rem;
            text-align: left;
        }
        .panel h3 {
            color: #64b5f6;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .panel h3 .icon { font-size: 1.2rem; }

        /* Status Panel */
        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .status-row:last-child { border-bottom: none; }
        .status-row .label { color: #8892b0; }
        .status-row .value {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4a4a6a;
        }
        .status-dot.active { background: #6bcb77; }
        .status-dot.processing { background: #ffd93d; animation: pulse 1s infinite; }
        .status-dot.error { background: #ff6b6b; }

        /* Info Panel */
        .info-text {
            color: #8892b0;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        .info-text p { margin-bottom: 0.5rem; }
        .ice-info {
            font-family: monospace;
            font-size: 0.8rem;
            color: #6bcb77;
            margin-top: 0.5rem;
        }

        /* Audio Test Panel */
        .audio-visualizer {
            width: 100%;
            height: 50px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            margin-bottom: 0.75rem;
        }
        .audio-controls {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .audio-level {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            color: #8892b0;
            font-size: 0.85rem;
        }
        .level-bar {
            flex: 1;
            height: 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .level-fill {
            height: 100%;
            background: linear-gradient(90deg, #6bcb77 0%, #ffd93d 70%, #ff6b6b 100%);
            width: 0%;
            transition: width 0.1s ease;
        }

        .mic-active {
            animation: mic-pulse 1s infinite;
        }
        @keyframes mic-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(233, 69, 96, 0.4); }
            50% { box-shadow: 0 0 0 20px rgba(233, 69, 96, 0); }
        }
        .error-text {
            color: #ff6b6b;
            margin-top: 1rem;
        }

        /* System Config Panel */
        .config-item { display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .config-item:last-child { border-bottom: none; }
        .config-label { color: #8892b0; font-size: 0.85rem; }
        .config-value { color: #6bcb77; font-family: monospace; font-size: 0.8rem; text-align: right; max-width: 60%; word-break: break-all; }
        .model-name { color: #64b5f6; }

        /* GPU Panel */
        .gpu-card { background: rgba(0,0,0,0.2); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.5rem; }
        .gpu-card:last-child { margin-bottom: 0; }
        .gpu-name { color: #64b5f6; font-size: 0.9rem; margin-bottom: 0.5rem; }
        .gpu-stat { display: flex; justify-content: space-between; margin-bottom: 0.3rem; }
        .gpu-stat-label { color: #8892b0; font-size: 0.8rem; }
        .gpu-stat-value { color: #fff; font-family: monospace; }
        .vram-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-top: 0.5rem; }
        .vram-fill { height: 100%; transition: width 0.3s ease; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Proof of Concept Voice AI</h1>
        <p class="subtitle">Self-hosted Realtime Voice Assistant</p>
        <div class="mode-badge">Local Mode (LAN)</div>

        <div class="status">
            <span class="status-indicator disconnected" id="statusIndicator"></span>
            <span id="statusText">Disconnected</span>
        </div>

        <button id="connectBtn" onclick="connect()">Connect</button>
        <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>

        <p class="error-text" id="errorText" style="display: none;"></p>

        <div class="panels">
            <!-- Connection Status Panel -->
            <div class="panel">
                <h3><span class="icon">&#9881;</span> Connection Status</h3>
                <div class="status-row">
                    <span class="label">WebRTC</span>
                    <span class="value">
                        <span class="status-dot" id="webrtcDot"></span>
                        <span id="webrtcStatus">-</span>
                    </span>
                </div>
                <div class="status-row">
                    <span class="label">ICE State</span>
                    <span class="value">
                        <span class="status-dot" id="iceDot"></span>
                        <span id="iceStatus">-</span>
                    </span>
                </div>
                <div class="status-row">
                    <span class="label">Signaling</span>
                    <span class="value">
                        <span class="status-dot" id="signalingDot"></span>
                        <span id="signalingStatus">-</span>
                    </span>
                </div>
                <div class="ice-info" id="iceInfo" style="display: none;">
                    ICE Servers: <span id="iceServersCount">0</span>
                </div>
            </div>

            <!-- Info Panel -->
            <div class="panel">
                <h3><span class="icon">&#128712;</span> Information</h3>
                <div class="info-text">
                    <p>Local mode uses direct WebRTC connections via SmallWebRTC.</p>
                    <p><strong>Best for:</strong> Same network (LAN) or localhost testing.</p>
                    <p><strong>Note:</strong> Real-time logging requires Daily.co mode.</p>
                </div>
            </div>

            <!-- System Configuration Panel -->
            <div class="panel">
                <h3><span class="icon">&#9881;</span> System Configuration</h3>
                <div class="config-item">
                    <span class="config-label">STT Model</span>
                    <span class="config-value model-name" id="sttModel">Loading...</span>
                </div>
                <div class="config-item">
                    <span class="config-label">Language</span>
                    <span class="config-value" id="sttLanguage">-</span>
                </div>
                <div class="config-item">
                    <span class="config-label">LLM Model</span>
                    <span class="config-value model-name" id="llmModel">Loading...</span>
                </div>
                <div class="config-item">
                    <span class="config-label">TTS Model</span>
                    <span class="config-value model-name" id="ttsModel">Loading...</span>
                </div>
                <div class="config-item">
                    <span class="config-label">Embedding</span>
                    <span class="config-value model-name" id="embeddingModel">Loading...</span>
                </div>
                <div class="config-item">
                    <span class="config-label">RAG</span>
                    <span class="config-value" id="ragStatus">-</span>
                </div>
            </div>

            <!-- GPU Status Panel -->
            <div class="panel">
                <h3><span class="icon">&#128187;</span> GPU Status</h3>
                <div id="gpuContainer"><div style="color: #8892b0; text-align: center;">Loading...</div></div>
            </div>

            <!-- Audio Test Panel -->
            <div class="panel" style="grid-column: span 2;">
                <h3><span class="icon">&#127908;</span> Audio Test</h3>
                <canvas class="audio-visualizer" id="audioVisualizer"></canvas>
                <div class="audio-level">
                    <span>Mic Level:</span>
                    <div class="level-bar">
                        <div class="level-fill" id="levelFill"></div>
                    </div>
                </div>
                <div class="audio-controls" style="margin-top: 0.75rem;">
                    <button class="button-secondary" onclick="testMic()">Test Microphone</button>
                    <button class="button-secondary" onclick="testSpeaker()">Test Speaker</button>
                    <button class="button-secondary" onclick="stopTest()">Stop Test</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let pc = null;
        let localStream = null;
        let audioContext = null;
        let analyser = null;
        let testStream = null;
        let animationId = null;

        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const errorText = document.getElementById('errorText');
        const levelFill = document.getElementById('levelFill');

        // Status elements
        const webrtcDot = document.getElementById('webrtcDot');
        const webrtcStatus = document.getElementById('webrtcStatus');
        const iceDot = document.getElementById('iceDot');
        const iceStatus = document.getElementById('iceStatus');
        const signalingDot = document.getElementById('signalingDot');
        const signalingStatus = document.getElementById('signalingStatus');
        const iceInfo = document.getElementById('iceInfo');
        const iceServersCount = document.getElementById('iceServersCount');

        function setStatus(status, text) {
            statusIndicator.className = 'status-indicator ' + status;
            statusText.textContent = text;
        }

        function showError(message) {
            errorText.textContent = message;
            errorText.style.display = 'block';
        }

        function hideError() {
            errorText.style.display = 'none';
        }

        function updateStatus(component, status, statusClass = '') {
            const dot = document.getElementById(component + 'Dot');
            const statusEl = document.getElementById(component + 'Status');
            if (dot && statusEl) {
                dot.className = 'status-dot ' + statusClass;
                statusEl.textContent = status;
            }
        }

        async function connect() {
            try {
                hideError();
                setStatus('connecting', 'Connecting...');
                connectBtn.disabled = true;

                // Reset status
                updateStatus('webrtc', 'Initializing...', 'processing');
                updateStatus('ice', '-', '');
                updateStatus('signaling', '-', '');

                // Fetch ICE servers from server
                const iceResponse = await fetch('/api/ice-servers');
                if (!iceResponse.ok) {
                    throw new Error('Failed to fetch ICE servers');
                }
                const iceConfig = await iceResponse.json();
                console.log('ICE servers:', iceConfig.iceServers);

                // Show ICE info
                iceInfo.style.display = 'block';
                iceServersCount.textContent = iceConfig.iceServers.length;

                // Get microphone access
                updateStatus('signaling', 'Getting mic...', 'processing');
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 16000
                    }
                });

                // Create peer connection with ICE servers
                pc = new RTCPeerConnection({
                    iceServers: iceConfig.iceServers,
                    iceTransportPolicy: 'all'
                });

                // Add local audio track
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // ICE connection state monitoring
                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    console.log('ICE connection state:', state);

                    switch (state) {
                        case 'new':
                            updateStatus('ice', 'New', '');
                            break;
                        case 'checking':
                            setStatus('connecting', 'Checking connectivity...');
                            updateStatus('ice', 'Checking...', 'processing');
                            break;
                        case 'connected':
                            setStatus('connected', 'Connected - Speak now!');
                            updateStatus('ice', 'Connected', 'active');
                            updateStatus('webrtc', 'Active', 'active');
                            connectBtn.classList.add('mic-active');
                            break;
                        case 'completed':
                            updateStatus('ice', 'Completed', 'active');
                            break;
                        case 'failed':
                            showError('Connection failed - ensure you are on the same network');
                            setStatus('disconnected', 'Connection failed');
                            updateStatus('ice', 'Failed', 'error');
                            break;
                        case 'disconnected':
                            updateStatus('ice', 'Disconnected', '');
                            setStatus('disconnected', 'Disconnected');
                            break;
                        case 'closed':
                            updateStatus('ice', 'Closed', '');
                            break;
                    }
                };

                // ICE gathering state
                pc.onicegatheringstatechange = () => {
                    console.log('ICE gathering state:', pc.iceGatheringState);
                };

                // Signaling state
                pc.onsignalingstatechange = () => {
                    console.log('Signaling state:', pc.signalingState);
                    switch (pc.signalingState) {
                        case 'stable':
                            updateStatus('signaling', 'Stable', 'active');
                            break;
                        case 'have-local-offer':
                            updateStatus('signaling', 'Local offer', 'processing');
                            break;
                        case 'have-remote-offer':
                            updateStatus('signaling', 'Remote offer', 'processing');
                            break;
                        case 'closed':
                            updateStatus('signaling', 'Closed', '');
                            break;
                    }
                };

                // Handle remote audio
                pc.ontrack = (event) => {
                    console.log('Received remote track');
                    const audio = new Audio();
                    audio.srcObject = event.streams[0];
                    audio.play().catch(e => console.log('Audio play error:', e));
                };

                // Create and send offer
                updateStatus('signaling', 'Creating offer...', 'processing');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Wait for ICE gathering
                updateStatus('ice', 'Gathering...', 'processing');
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                    } else {
                        pc.onicegatheringstatechange = () => {
                            if (pc.iceGatheringState === 'complete') {
                                resolve();
                            }
                        };
                    }
                });

                // Send offer to server
                updateStatus('signaling', 'Sending offer...', 'processing');
                const response = await fetch('/api/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sdp: pc.localDescription.sdp,
                        type: pc.localDescription.type
                    })
                });

                if (!response.ok) {
                    throw new Error('Server error: ' + response.status);
                }

                const answer = await response.json();
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                updateStatus('signaling', 'Answer received', 'active');

                disconnectBtn.disabled = false;

            } catch (error) {
                console.error('Connection error:', error);
                showError(error.message);
                setStatus('disconnected', 'Error: ' + error.message);
                connectBtn.disabled = false;
                updateStatus('webrtc', 'Error', 'error');
                disconnect();
            }
        }

        function disconnect() {
            if (pc) {
                pc.close();
                pc = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            setStatus('disconnected', 'Disconnected');
            connectBtn.disabled = false;
            disconnectBtn.disabled = true;
            connectBtn.classList.remove('mic-active');

            // Reset status
            updateStatus('webrtc', '-', '');
            updateStatus('ice', '-', '');
            updateStatus('signaling', '-', '');
            iceInfo.style.display = 'none';
        }

        // Audio Test Functions
        async function testMic() {
            try {
                stopTest();

                testStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;

                const source = audioContext.createMediaStreamSource(testStream);
                source.connect(analyser);

                drawVisualizer();
            } catch (e) {
                showError('Microphone access denied: ' + e.message);
            }
        }

        function drawVisualizer() {
            const canvas = document.getElementById('audioVisualizer');
            const ctx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                animationId = requestAnimationFrame(draw);

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;

                // Calculate average level for the level meter
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height;
                    sum += dataArray[i];

                    // Color gradient from green to red
                    const hue = 120 - (dataArray[i] / 255) * 60;
                    ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

                    x += barWidth + 1;
                }

                // Update level meter
                const level = (sum / bufferLength / 255) * 100;
                levelFill.style.width = level + '%';
            }

            draw();
        }

        function testSpeaker() {
            stopTest();

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);

            oscillator.start();

            // Stop after 1 second
            setTimeout(() => {
                oscillator.stop();
            }, 1000);
        }

        function stopTest() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            if (testStream) {
                testStream.getTracks().forEach(track => track.stop());
                testStream = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            analyser = null;
            levelFill.style.width = '0%';

            // Clear canvas
            const canvas = document.getElementById('audioVisualizer');
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            stopTest();
            disconnect();
        });

        // Load system configuration
        async function loadSystemInfo() {
            try {
                const response = await fetch('/api/system/info');
                const data = await response.json();

                const truncate = (name) => {
                    const parts = name.split('/');
                    return parts.length > 1 ? parts[parts.length - 1] : name;
                };

                document.getElementById('sttModel').textContent = truncate(data.models.stt.name);
                document.getElementById('sttModel').title = data.models.stt.name;
                document.getElementById('sttLanguage').textContent = data.models.stt.language.toUpperCase();
                document.getElementById('llmModel').textContent = truncate(data.models.llm.name);
                document.getElementById('llmModel').title = data.models.llm.name;
                document.getElementById('ttsModel').textContent = data.models.tts.name;
                document.getElementById('embeddingModel').textContent = truncate(data.models.embedding.name);
                document.getElementById('embeddingModel').title = data.models.embedding.name;
                document.getElementById('ragStatus').textContent = data.rag.enabled ? 'Enabled' : 'Disabled';
                document.getElementById('ragStatus').style.color = data.rag.enabled ? '#6bcb77' : '#ff6b6b';
            } catch (e) { console.error('Failed to load system info:', e); }
        }

        // Load GPU status
        async function loadGpuStatus() {
            const container = document.getElementById('gpuContainer');
            try {
                const response = await fetch('/api/system/gpu');
                const data = await response.json();

                if (data.gpu_count === 0) {
                    container.innerHTML = '<div style="color: #8892b0; text-align: center;">No GPU detected</div>';
                    return;
                }

                let html = '';
                for (const gpu of data.gpus) {
                    const color = gpu.memory_percent > 90 ? '#ff6b6b' : gpu.memory_percent > 70 ? '#ffd93d' : '#6bcb77';
                    html += `
                        <div class="gpu-card">
                            <div class="gpu-name">GPU ${gpu.index}: ${gpu.name}</div>
                            <div class="gpu-stat">
                                <span class="gpu-stat-label">VRAM</span>
                                <span class="gpu-stat-value">${gpu.memory_used_mb} / ${gpu.memory_total_mb} MB (${gpu.memory_percent}%)</span>
                            </div>
                            <div class="vram-bar"><div class="vram-fill" style="width: ${gpu.memory_percent}%; background: ${color}"></div></div>
                        </div>`;
                }
                container.innerHTML = html;
            } catch (e) {
                container.innerHTML = '<div style="color: #ff6b6b; text-align: center;">GPU info unavailable</div>';
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSystemInfo();
            loadGpuStatus();
            setInterval(loadGpuStatus, 5000); // Poll every 5 seconds
        });
    </script>
</body>
</html>
